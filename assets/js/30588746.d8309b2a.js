"use strict";(self.webpackChunkpublic_notes=self.webpackChunkpublic_notes||[]).push([[3850],{1202:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var s=r(5893),a=r(1151);const t={sidebar_position:10},i="Oh Shit, Perl",o={id:"tech/oh-shit-x/perl",title:"Oh Shit, Perl",description:"You can access to this page from ohshitperl.com, ohshit.foo/perl or ohshit.bar/perl.",source:"@site/docs/0100-tech/060-oh-shit-x/010-perl.md",sourceDirName:"0100-tech/060-oh-shit-x",slug:"/tech/oh-shit-x/perl",permalink:"/tech/oh-shit-x/perl",draft:!1,unlisted:!1,editUrl:"https://github.com/ahmadalli/public-notes/edit/main/docs/0100-tech/060-oh-shit-x/010-perl.md",tags:[],version:"current",lastUpdatedBy:"ahmadali shafiee",lastUpdatedAt:1710973441e3,sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Oh Shit, X",permalink:"/tech/oh-shit-x/"},next:{title:"Oh Shit, Python",permalink:"/tech/oh-shit-x/python"}},l={},d=[{value:"Operators",id:"operators",level:2},{value:"<code>==</code>",id:"",level:3},{value:"<code>+</code>",id:"-1",level:3},{value:"<code>q</code> and <code>qq</code>",id:"q-and-qq",level:3},{value:"<code>&lt;=&gt;</code>",id:"-2",level:3},{value:"<code>=&gt;</code> (Fat Comma) and <code>,=&gt;</code> (Winking Fat Comma)",id:"-fat-comma-and--winking-fat-comma",level:3},{value:"<code>=~</code>",id:"-3",level:3},{value:"Precedence",id:"precedence",level:3},{value:"Secret Operators",id:"secret-operators",level:3},{value:"Arrays, Hashes, and Lists",id:"arrays-hashes-and-lists",level:2},{value:"Flow Control",id:"flow-control",level:2},{value:"Next, Last, Redo, and Continue",id:"next-last-redo-and-continue",level:3},{value:"For and Foreach",id:"for-and-foreach",level:3},{value:"Boolean",id:"boolean",level:3},{value:"Subroutines",id:"subroutines",level:2},{value:"wantarray",id:"wantarray",level:3},{value:"Classes",id:"classes",level:2},{value:"More Resources",id:"more-resources",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components},{Icon:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Icon",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"oh-shit-perl",children:"Oh Shit, Perl"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["You can access to this page from ",(0,s.jsx)(n.a,{href:"https://ohshitperl.com",children:"ohshitperl.com"}),", ",(0,s.jsx)(n.a,{href:"https://ohshit.foo/perl",children:"ohshit.foo/perl"})," or ",(0,s.jsx)(n.a,{href:"https://ohshit.bar/perl",children:"ohshit.bar/perl"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,s.jsxs)(n.p,{children:["Perl has ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/perlop",children:"a lot of operators"}),", and some of them are a bit weird. Here are some of them:"]}),"\n",(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.code,{children:"=="})}),"\n",(0,s.jsxs)(n.p,{children:["These are all ",(0,s.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'1 == 1\n1 == 1.0\n1 == "1"\n1 == "1.0"\n1 == "a1.0aa\\n"\n"foo" == "bar"; # because why not?\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This happens because ",(0,s.jsx)(n.code,{children:"=="})," is for numbers only, and strings without any numbers in them would be casted to ",(0,s.jsx)(n.code,{children:"0"}),", and so in Perl's world ",(0,s.jsx)(n.code,{children:'"foo" == "bar"'}),". For strings ",(0,s.jsx)(n.code,{children:"eq"})," should be used instead."]}),"\n",(0,s.jsx)(n.h3,{id:"-1",children:(0,s.jsx)(n.code,{children:"+"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"+"})," is for numbers which is why ",(0,s.jsx)(n.code,{children:"string"})," + ",(0,s.jsx)(n.code,{children:"int"})," returns int, even if the string isn't completely made of numbers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'print "123aaa" + 2; # this will return 125\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.a,{href:"https://stackoverflow.com/a/8539065/1003464",children:[(0,s.jsx)(r,{icon:"fa-brands fa-stack-overflow",size:"lg"})," This is used"]})," to convert strings to int as well."]}),"\n",(0,s.jsxs)(n.h3,{id:"q-and-qq",children:[(0,s.jsx)(n.code,{children:"q"})," and ",(0,s.jsx)(n.code,{children:"qq"})]}),"\n",(0,s.jsxs)(n.p,{children:["You can change ",(0,s.jsx)(n.code,{children:"'"})," and ",(0,s.jsx)(n.code,{children:'"'})," using ",(0,s.jsx)(n.code,{children:"q"})," and ",(0,s.jsx)(n.code,{children:"qq"})," operator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my $var = "Hello World from \\"$_\\"";\nmy $easy_var = qq\\Hello World from "$_"\\;\nmy $weird_syntax = qq qHello World from \\qq;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-2",children:(0,s.jsx)(n.code,{children:"<=>"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<=>"})," (which could be a method, like ",(0,s.jsx)(n.code,{children:"CompareTo"})," in C#) returns ",(0,s.jsx)(n.code,{children:"-1"}),", ",(0,s.jsx)(n.code,{children:"0"}),", or ",(0,s.jsx)(n.code,{children:"1"})," based on the comparison result. It's used to compare numbers, and it's used in ",(0,s.jsx)(n.code,{children:"sort"})," method."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:"my @sorted = sort { $a <=> $b } @unsorted;\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"-fat-comma-and--winking-fat-comma",children:[(0,s.jsx)(n.code,{children:"=>"})," (Fat Comma) and ",(0,s.jsx)(n.code,{children:",=>"})," (Winking Fat Comma)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"=>"}),", called fat command has similar functionality to ",(0,s.jsx)(n.code,{children:","})," (comma), with additional functionality of automatically quoting the left side. It's a syntactic sugar used for hashes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:"my %hash = (a => 1, b => 2, c => 3);\nmy @array = (a => b => c => d); # there's nothing special about =>, it's just a comma with left side quoting\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and if you don't want the left side to be quoted, you can use ",(0,s.jsx)(n.code,{children:",=>"})," (winking fat comma)."]}),"\n",(0,s.jsx)(n.h3,{id:"-3",children:(0,s.jsx)(n.code,{children:"=~"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"=~"})," doesn't have a consistent behavior. It returns a list of matches when used with ",(0,s.jsx)(n.code,{children:"m/.../"})," to match the left side with the regex on the right side, but it's a binding operator when used with ",(0,s.jsx)(n.code,{children:"s/.../.../"})," to replace the left side with the right side."]}),"\n",(0,s.jsx)(n.p,{children:"Also it can be used inside a while loop to iterate over matches:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my $str = "hello world this is a test for regex in perl";\nwhile ($str =~ /(\\w+)/g) {\n  print "Word is $1, ends at position ", pos $str, "\\n";\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"precedence",children:"Precedence"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/perlop#Operator-Precedence-and-Associativity",children:"Operator Precedence and Associativity"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://stackoverflow.com/q/15193327/1003464",children:[(0,s.jsx)(r,{icon:"fa-brands fa-stack-overflow",size:"lg"})," Why do Perl's logical operators &&, ||, ! take precedence over and, or, and not?"]})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"secret-operators",children:"Secret Operators"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://metacpan.org/dist/perlsecret/view/lib/perlsecret.pod",children:"perlsecret - Perl secret operators and constants"})}),"\n",(0,s.jsx)(n.h2,{id:"arrays-hashes-and-lists",children:"Arrays, Hashes, and Lists"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Lists aren't data structures, they're just a way to group values together. They would be stored in memory either as an array or a hash when assigned to a variable."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can have a scalar, an array, and a hash with the same name."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my $var = "scalar";\nmy @var = ("array");\nmy %var = ("hash" => "value");\nprint "\\$var = $var\\n\\@var = @var\\n\\%var = %var\\n";\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["To get values out of arrays and hashes, you need to indicate the expected output type with ",(0,s.jsx)(n.code,{children:"$"})," (scalar), ",(0,s.jsx)(n.code,{children:"@"})," (array), or ",(0,s.jsx)(n.code,{children:"%"})," (hash) sigils prefixes, and ",(0,s.jsx)(n.code,{children:"[]"})," for arrays or ",(0,s.jsx)(n.code,{children:"{}"})," for hashes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my @array = ("a", "b", "c", "d");\nmy %hash = ("a" => 1, "b" => 2, "c" => 3);\nprint "array[0] = $array[0]\\n";\nprint "hash{a} = $hash{a}\\n";\nprint qq/hash out of array = @hash{"a", "b"}\\n/;\nprint qq/array out of hash = %array{"a", "b"}\\n/;\n'})}),"\n",(0,s.jsx)(n.p,{children:"This can get very confusing if you reuse variable names for different types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my @var = ("a", "b", "c", "d");\nmy %var = ("a" => 1, "b" => 2, "c" => 3);\nmy $var = "scalar";\n\nprint "\\$var{a} = $var{a}\\n"; # prints 1, returns scalar from hash\nprint "\\$var[0] = $var[0]\\n"; # prints a, returns scalar from array\nprint qq/\\@var{"a", "b"} = @var{a, b}\\n/; # prints 1 2, returns array (because of @) from hash (because of {})\nprint qq/\\%var[0,1] = %var{"a", "b"}\\n/; # prints 0 => a, 1 => b, returns hash (because of %) from array (because of [])\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"List of lists is not a 2D array, it'll be flattened into a 1D array:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my @array = (1, 2, 3, (4, 5, 6), 7, 8, 9);\nprint "@array\\n"; # prints 1 2 3 4 5 6 7 8 9\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"To create a 2D array, you need to use references:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my @array = (1, 2, 3, [4, 5, 6], 7, 8, 9);\nprint "@array\\n"; # prints 1 2 3 ARRAY(0x1f9f8a0) 7 8 9\nprint "@{$array[3]}\\n"; # prints 4 5 6\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can use lists to set values of multiple variables at once:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my ($a, $b, $c) = (1, 2, 3);\nprint "$a $b $c\\n"; # prints 1 2 3\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When initializing multiple arrays using a list, the leftmost array is greedy and takes all the values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'my (@array1, $array2) = (1, 2, 3, (4, 5, 6), 7, 8, 9);\nprint "@array1\\n"; # prints 1 2 3 4 5 6 7 8 9\nprint "$array2\\n"; # prints nothing\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"flow-control",children:"Flow Control"}),"\n",(0,s.jsx)(n.h3,{id:"next-last-redo-and-continue",children:"Next, Last, Redo, and Continue"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"last"})," is the same as ",(0,s.jsx)(n.code,{children:"break"})," in C# and ",(0,s.jsx)(n.code,{children:"next"})," is the same as ",(0,s.jsx)(n.code,{children:"continue"})," in C#. Additionally, ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/functions/redo",children:(0,s.jsx)(n.code,{children:"redo"})})," is used to restart the loop without reevaluating the condition and ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/functions/continue",children:(0,s.jsx)(n.code,{children:"continue"})})," is like ",(0,s.jsx)(n.code,{children:"finally"})," in exception handling, for the ",(0,s.jsx)(n.code,{children:"next"})," statement."]}),"\n",(0,s.jsx)(n.p,{children:"Take the example from perldoc:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:"while (EXPR) {\n    ### redo always comes here\n    do_something;\n} continue {\n    ### next always comes here\n    do_something_else;\n    # then back the top to re-check EXPR\n}\n### last always comes here\n"})}),"\n",(0,s.jsx)(n.h3,{id:"for-and-foreach",children:"For and Foreach"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"for"})," and ",(0,s.jsx)(n.code,{children:"foreach"})," are the same and can be used interchangeably."]}),"\n",(0,s.jsx)(n.h3,{id:"boolean",children:"Boolean"}),"\n",(0,s.jsxs)(n.p,{children:["Perl doesn't have a boolean type, it uses falsey and truthy values instead. The falsey values are ",(0,s.jsx)(n.code,{children:"undef"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:'""'}),", ",(0,s.jsx)(n.code,{children:'"0"'}),", and empty list, array, and hash. Everything else is truthy."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'print undef ? "true" : "false"; # prints false\nprint 0 ? "true" : "false"; # prints false\nprint "" ? "true" : "false"; # prints false\nprint "0" ? "true" : "false"; # prints false\nprint "false" ? "true" : "false"; # prints true\nprint "0.0" ? "true" : "false"; # prints true\nprint () ? "true" : "false"; # prints false\nmy @array = ();\nprint @array ? "true" : "false"; # prints false\nmy %hash = ();\nprint %hash ? "true" : "false"; # prints false\n'})}),"\n",(0,s.jsx)(n.h2,{id:"subroutines",children:"Subroutines"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["There's no proper way to define subroutine arguments and return. Everything that's passed to the subroutine is stored in ",(0,s.jsx)(n.code,{children:"@_"})," array, and you need to manually check the number of arguments and their types."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can call subroutines without parenthesis."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'sub test {\n  print $_[0] . " " . $_[1] . "\\n";\n}\n\ntest "hello", "world";\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["There's no proper way to define subroutine return types as well. See ",(0,s.jsx)(n.a,{href:"#wantarray",children:"wantarray"})," for more oh shit moments."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Variables passed to the subroutine are passed by reference and if you modify values of the ",(0,s.jsx)(n.code,{children:"@_"})," array, original values would be modified as well. It's a good practice to always unpack ",(0,s.jsx)(n.code,{children:"@_"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:"sub test1 {\n  my $arg1 = $_[0];\n}\n\nsub test2 {\n  my $arg1 = shift; # Because it's Perl, and @_ would be the unannounced argument for shift and pop: https://perldoc.perl.org/perlvar#@_\n}\n\nsub test3 {\n  my ($arg1, $arg2) = @_;\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You can expect a hash as the subroutine's input and create a hash from ",(0,s.jsx)(n.code,{children:"@_"})," on the subroutine. This approach has the benefit of copying the values, having named parameters, and being able to set default values for parameters."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'sub test {\n  my %args = (\n    first_arg = "default value",\n    second_arg = undef,\n    @_ # use @_ as a hash and overwrite the hash values if they exist on @_\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["But this approach doesn't support references. ",(0,s.jsx)(n.code,{children:'test({ second_arg = "world" });'})," doesn't work because in this case ",(0,s.jsx)(n.code,{children:"$_[0]"})," would be a hash reference, and would not be unpacked into the hash. To support this case, you need to dereference the hash reference:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'sub test {\n  my %args = (\n    first_arg = "default value",\n    second_arg = undef,\n    ref($_[0]) ? %{$_[0]} : @_\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["But note that this approach is not perfect and is error prone. For example, ",(0,s.jsx)(n.code,{children:'test(first_arg=>"hello", { second_arg = "world" });'})," would not unpack ",(0,s.jsx)(n.code,{children:"second_arg"})," because ",(0,s.jsx)(n.code,{children:"ref($_[0])"})," would be false and ",(0,s.jsx)(n.code,{children:"@_"})," would be used instead of dereferencing the hash reference."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["To keep it simple, just use ",(0,s.jsx)(n.code,{children:"@_"})," and unpack it."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You can ",(0,s.jsxs)(n.a,{href:"https://www.effectiveperlprogramming.com/2015/04/use-v5-20-subroutine-signatures/",children:["use the experimental ",(0,s.jsx)(n.code,{children:"signatures"})," feature"]})," to define subroutine arguments."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You can omit ",(0,s.jsx)(n.code,{children:"return <something>;"})," and use ",(0,s.jsx)(n.code,{children:"<something>"})," instead."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:'sub test {\n  return "hello";\n}\n\nsub test2 {\n  "hello"\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You can omit ",(0,s.jsx)(n.code,{children:"$_"})," ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/perlvar#$_",children:"in some operators and functions"})," to write shorter code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-perl",children:"print for @array;\ngrep { m/<some regex>/ } @array;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This can also be used for bash one-liners:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"perl -ne 'print if m/<some regex>/' <file>\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"wantarray",children:"wantarray"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"wantarray"})," depends on the ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/functions/caller",children:(0,s.jsx)(n.strong,{children:"context"})})," of the function call, meaning what you're doing with the return value of the function. If you're not doing anything with the return value, it's ",(0,s.jsx)(n.code,{children:"undef"}),". If you're assigning it to a scalar, it's false. If you're assigning it to a list, it's true."]}),"\n",(0,s.jsxs)(n.p,{children:["This function creates a lot of confusion because there's no guarantee that the function is using ",(0,s.jsx)(n.code,{children:"wantarray"})," in its implementation, and how it's using it. Therefore it's recommended to avoid using it."]}),"\n",(0,s.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Other than scalar, array, and hash, there are no other data structures in Perl."})}),"\n",(0,s.jsxs)(n.li,{children:["Object oriented programming is not built into the language, and you need to use modules to implement it. ",(0,s.jsx)(n.a,{href:"https://perldoc.perl.org/perlobj#An-Object-is-Simply-a-Data-Structure",children:"An Object is Simply a Data Structure"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["There's no reserved name for constructors, and you can use any name you want. ",(0,s.jsx)(n.code,{children:"new"})," is just a convention."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"more-resources",children:"More Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://buttondown.email/hillelwayne/archive/raku-a-language-for-gremlins/",children:"Raku: A Language for Gremlins"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://news.ycombinator.com/item?id=37040681",children:[(0,s.jsx)(r,{icon:"fa-brands fa-y-combinator",size:"lg"})," YC discussion"]})}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>i});var s=r(7294);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);